1. entity:
> package com.encapsulearn.quizApp.entity;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import lombok.Data;
import java.util.List;

@Entity
@Data
public class Question {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(columnDefinition = "TEXT")
  private String text;

  @ElementCollection(fetch = FetchType.EAGER)
  @CollectionTable(name = "question_options", joinColumns = @JoinColumn(name = "question_id"))
  @Column(name = "option_text", columnDefinition = "TEXT")
  private List<String> options;

  private int correctOptionIndex;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "quiz_id")
  @JsonBackReference
  private Quiz quiz;
}

> package com.encapsulearn.quizApp.entity;

import com.encapsulearn.quizApp.enums.QuizStatus;
import jakarta.persistence.*;
import lombok.Data;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Data
public class Quiz {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  private String title;
  private String category;
  private LocalDateTime schedule;

  @Enumerated(EnumType.STRING)
  private QuizStatus status;

  @OneToMany(mappedBy = "quiz", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
  private List<Question> questions = new ArrayList<>();
}

> package com.encapsulearn.quizApp.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;

@Entity
@Data
@NoArgsConstructor
public class QuizAttempt {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "user_id", nullable = false)
  private User user;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "quiz_id", nullable = false)
  private Quiz quiz;

  private int score;
  private int totalQuestions;
  private LocalDateTime date;

  @Column(columnDefinition = "TEXT")
  private String answers; // User's answers stored as JSON string
}

> package com.encapsulearn.quizApp.entity;

import com.encapsulearn.quizApp.enums.ERole;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "roles")
@Data
@NoArgsConstructor
public class Role {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Integer id;

  @Enumerated(EnumType.STRING)
  @Column(length = 20)
  private ERole name;

  public Role(ERole name) {
    this.name = name;
  }
}

> package com.encapsulearn.quizApp.entity;

import java.util.HashSet;
import java.util.Set;
import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(unique = true, nullable = false)
    private String email;

    @Column(nullable = false)
    private String password;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "user_roles",
               joinColumns = @JoinColumn(name = "user_id"),
               inverseJoinColumns = @JoinColumn(name = "role_id"))
    private Set<Role> roles = new HashSet<>();

    public User(String username, String email, String password) {
        this.username = username;
        this.email = email;
        this.password = password;
    }
}


2. enums:
> package com.encapsulearn.quizApp.enums;

public enum ERole {
    ROLE_USER,
    ROLE_ADMIN
}

> package com.encapsulearn.quizApp.enums;

public enum QuizStatus {

  UPCOMING,
  CURRENT,
  COMPLETED
}


3. dto:
> package com.encapsulearn.quizApp.dto;

import lombok.Data;
import java.util.List;

@Data
public class JwtResponse {
  private String token;
  private String type = "Bearer";
  private Long id;
  private String username;
  private String email; // Added email
  private List<String> roles;

  public JwtResponse(String accessToken, Long id, String username, String email, List<String> roles) {
    this.token = accessToken;
    this.id = id;
    this.username = username;
    this.email = email;
    this.roles = roles;
  }
}

> package com.encapsulearn.quizApp.dto;

import lombok.Data;

@Data
public class LoginRequest {
  private String email;
  private String password;
}

> package com.encapsulearn.quizApp.dto;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class MessageResponse {
  private String message;
}

> package com.encapsulearn.quizApp.dto;

import lombok.Data;
import java.util.List;

@Data
public class QuestionDto {
  private Long id;
  private String text;
  private List<String> options;
  // correctOptionIndex is intentionally omitted for users
}

> package com.encapsulearn.quizApp.dto;

import lombok.Data;
import java.time.LocalDateTime;

@Data
public class QuizAttemptDto {
  private Long id;
  private Long quizId;
  private String quizTitle;
  private int score;
  private int totalQuestions;
  private LocalDateTime date;
  private Object answers; // For flexibility
}

> package com.encapsulearn.quizApp.dto;

import com.encapsulearn.quizApp.enums.QuizStatus;
import lombok.Data;
import java.time.LocalDateTime;
import java.util.List;

@Data
public class QuizDto {
  private Long id;
  private String title;
  private String category;
  private LocalDateTime schedule;
  private QuizStatus status;
  private List<QuestionDto> questions;
}

> package com.encapsulearn.quizApp.dto;

import lombok.Data;
import java.util.Map;

@Data
public class QuizSubmissionDto {
  private Long quizId;
  private Map<String, Integer> answers; // questionId -> selectedOptionIndex
}

> package com.encapsulearn.quizApp.dto;

import lombok.Data;

@Data
public class RegisterRequest {
  private String username;
  private String email;
  private String password;
}


4. repository:
> package com.encapsulearn.quizApp.repository;

import com.encapsulearn.quizApp.entity.QuizAttempt;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface QuizAttemptRepository extends JpaRepository<QuizAttempt, Long> {
  List<QuizAttempt> findByUserIdOrderByDateDesc(Long userId);
}

> package com.encapsulearn.quizApp.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import com.encapsulearn.quizApp.entity.Quiz;
import com.encapsulearn.quizApp.enums.QuizStatus;

public interface QuizRepository extends JpaRepository<Quiz, Long> {

  List<Quiz> findByStatus(QuizStatus quizStatus);
}

> package com.encapsulearn.quizApp.repository;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;

import com.encapsulearn.quizApp.entity.Role;
import com.encapsulearn.quizApp.enums.ERole;

public interface RoleRepository extends JpaRepository<Role, Integer> {
  Optional<Role> findByName(ERole name);
}

> package com.encapsulearn.quizApp.repository;

import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import com.encapsulearn.quizApp.entity.User;

public interface UserRepository extends JpaRepository<User, Long> {
  Optional<User> findByEmail(String email);

  Boolean existsByUsername(String username);

  Boolean existsByEmail(String email);
}


5. service:
> package com.encapsulearn.quizApp.service;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;

import com.encapsulearn.quizApp.dto.JwtResponse;
import com.encapsulearn.quizApp.dto.LoginRequest;
import com.encapsulearn.quizApp.dto.RegisterRequest;
import com.encapsulearn.quizApp.entity.Role;
import com.encapsulearn.quizApp.entity.User;
import com.encapsulearn.quizApp.enums.ERole;
import com.encapsulearn.quizApp.repository.RoleRepository;
import com.encapsulearn.quizApp.repository.UserRepository;
import com.encapsulearn.quizApp.security.JwtUtils;
import com.encapsulearn.quizApp.security.UserDetailsImpl;

@Service
public class AuthService {

  @Autowired
  AuthenticationManager authenticationManager;

  @Autowired
  UserRepository userRepository;

  @Autowired
  RoleRepository roleRepository;

  @Autowired
  PasswordEncoder encoder;

  @Autowired
  JwtUtils jwtUtils;

  public JwtResponse authenticateUser(LoginRequest loginRequest) {
    Authentication authentication = authenticationManager.authenticate(
        new UsernamePasswordAuthenticationToken(loginRequest.getEmail(), loginRequest.getPassword()));

    SecurityContextHolder.getContext().setAuthentication(authentication);
    String jwt = jwtUtils.generateJwtToken(authentication);

    UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
    List<String> roles = userDetails.getAuthorities().stream()
        .map(item -> item.getAuthority())
        .collect(Collectors.toList());

    return new JwtResponse(jwt,
        userDetails.getId(),
        userDetails.getUsername(),
        userDetails.getEmail(),
        roles);
  }

  public void registerUser(RegisterRequest registerRequest) {
    if (userRepository.existsByUsername(registerRequest.getUsername())) {
      throw new RuntimeException("Error: Username is already taken!");
    }
    if (userRepository.existsByEmail(registerRequest.getEmail())) {
      throw new RuntimeException("Error: Email is already in use!");
    }

    User user = new User(registerRequest.getUsername(),
        registerRequest.getEmail(),
        encoder.encode(registerRequest.getPassword()));

    Set<Role> roles = new HashSet<>();
    Role userRole = roleRepository.findByName(ERole.ROLE_USER)
        .orElseThrow(() -> new RuntimeException("Error: Role is not found."));
    roles.add(userRole);

    user.setRoles(roles);
    userRepository.save(user);
  }
}

> package com.encapsulearn.quizApp.service;

import com.encapsulearn.quizApp.dto.*;
import com.encapsulearn.quizApp.entity.Question;
import com.encapsulearn.quizApp.entity.Quiz;
import com.encapsulearn.quizApp.entity.QuizAttempt;
import com.encapsulearn.quizApp.entity.User;
import com.encapsulearn.quizApp.enums.QuizStatus;
import com.encapsulearn.quizApp.repository.QuizAttemptRepository;
import com.encapsulearn.quizApp.repository.QuizRepository;
import com.encapsulearn.quizApp.repository.UserRepository;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class QuizService {

  @Autowired
  private QuizRepository quizRepository;
  @Autowired
  private QuizAttemptRepository quizAttemptRepository;
  @Autowired
  private UserRepository userRepository;
  @Autowired
  private ObjectMapper objectMapper;

  @Transactional
  public Quiz createQuiz(Quiz quiz) {
    quiz.getQuestions().forEach(question -> question.setQuiz(quiz));
    return quizRepository.save(quiz);
  }

  @Transactional(readOnly = true)
  public List<QuizDto> getAllQuizzes(Optional<String> status) {
    updateQuizStatuses();
    List<Quiz> quizzes;
    if (status.isPresent()) {
      try {
        QuizStatus quizStatus = QuizStatus.valueOf(status.get().toUpperCase());
        quizzes = quizRepository.findByStatus(quizStatus);
      } catch (IllegalArgumentException e) {
        quizzes = quizRepository.findAll();
      }
    } else {
      quizzes = quizRepository.findAll();
    }
    return quizzes.stream().map(this::convertToDto).collect(Collectors.toList());
  }

  @Transactional(readOnly = true)
  public QuizDto getQuizById(Long id) {
    updateQuizStatuses();
    Quiz quiz = quizRepository.findById(id).orElseThrow(() -> new RuntimeException("Quiz not found"));
    return convertToDto(quiz);
  }

  @Transactional
  public QuizAttempt submitQuiz(QuizSubmissionDto submission, Long userId) {
    User user = userRepository.findById(userId).orElseThrow(() -> new RuntimeException("User not found"));
    Quiz quiz = quizRepository.findById(submission.getQuizId())
        .orElseThrow(() -> new RuntimeException("Quiz not found"));

    int score = 0;
    for (Question question : quiz.getQuestions()) {
      Integer userAnswerIndex = submission.getAnswers().get(String.valueOf(question.getId()));
      if (userAnswerIndex != null && userAnswerIndex == question.getCorrectOptionIndex()) {
        score++;
      }
    }

    QuizAttempt attempt = new QuizAttempt();
    attempt.setUser(user);
    attempt.setQuiz(quiz);
    attempt.setScore(score);
    attempt.setTotalQuestions(quiz.getQuestions().size());
    attempt.setDate(LocalDateTime.now());
    try {
      attempt.setAnswers(objectMapper.writeValueAsString(submission.getAnswers()));
    } catch (JsonProcessingException e) {
      throw new RuntimeException("Could not serialize answers", e);
    }

    quiz.setStatus(QuizStatus.COMPLETED);
    quizRepository.save(quiz);

    return quizAttemptRepository.save(attempt);
  }

  @Transactional(readOnly = true)
  public List<QuizAttemptDto> getQuizHistoryForUser(Long userId) {
    return quizAttemptRepository.findByUserIdOrderByDateDesc(userId)
        .stream().map(this::convertAttemptToDto).collect(Collectors.toList());
  }

  private void updateQuizStatuses() {
    List<Quiz> quizzes = quizRepository.findAll();
    LocalDateTime now = LocalDateTime.now();
    for (Quiz quiz : quizzes) {
      if (quiz.getStatus() != QuizStatus.COMPLETED) {
        if (now.isAfter(quiz.getSchedule()) && now.isBefore(quiz.getSchedule().plusHours(1))) { // Assuming 1 hour
                                                                                                // duration
          quiz.setStatus(QuizStatus.CURRENT);
        } else if (now.isBefore(quiz.getSchedule())) {
          quiz.setStatus(QuizStatus.UPCOMING);
        }
      }
    }
    quizRepository.saveAll(quizzes);
  }

  private QuizDto convertToDto(Quiz quiz) {
    QuizDto quizDto = new QuizDto();
    quizDto.setId(quiz.getId());
    quizDto.setTitle(quiz.getTitle());
    quizDto.setCategory(quiz.getCategory());
    quizDto.setSchedule(quiz.getSchedule());
    quizDto.setStatus(quiz.getStatus());

    List<QuestionDto> questionDtos = quiz.getQuestions().stream().map(question -> {
      QuestionDto questionDto = new QuestionDto();
      questionDto.setId(question.getId());
      questionDto.setText(question.getText());
      questionDto.setOptions(question.getOptions());
      return questionDto;
    }).collect(Collectors.toList());

    quizDto.setQuestions(questionDtos);
    return quizDto;
  }

  private QuizAttemptDto convertAttemptToDto(QuizAttempt attempt) {
    QuizAttemptDto dto = new QuizAttemptDto();
    dto.setId(attempt.getId());
    dto.setQuizId(attempt.getQuiz().getId());
    dto.setQuizTitle(attempt.getQuiz().getTitle());
    dto.setScore(attempt.getScore());
    dto.setTotalQuestions(attempt.getTotalQuestions());
    dto.setDate(attempt.getDate());
    try {
      dto.setAnswers(objectMapper.readValue(attempt.getAnswers(), Object.class));
    } catch (JsonProcessingException e) {
      dto.setAnswers(null);
    }
    return dto;
  }
}


6. controller:
> package com.encapsulearn.quizApp.controller;

import com.encapsulearn.quizApp.entity.Quiz;
import com.encapsulearn.quizApp.service.QuizService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/admin")
@CrossOrigin(origins = "${web.cors.allowed-origins}", maxAge = 3600)
@PreAuthorize("hasRole('ADMIN')")
public class AdminController {

  @Autowired
  private QuizService quizService;

  @PostMapping("/quizzes")
  public ResponseEntity<Quiz> createQuiz(@RequestBody Quiz quiz) {
    return ResponseEntity.ok(quizService.createQuiz(quiz));
  }
}

> package com.encapsulearn.quizApp.controller;

import com.encapsulearn.quizApp.dto.JwtResponse;
import com.encapsulearn.quizApp.dto.LoginRequest;
import com.encapsulearn.quizApp.dto.MessageResponse;
import com.encapsulearn.quizApp.dto.RegisterRequest;
import com.encapsulearn.quizApp.service.AuthService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/auth")
@CrossOrigin(origins = "${web.cors.allowed-origins}", maxAge = 3600)
public class AuthController {

  @Autowired
  private AuthService authService;

  @PostMapping("/signin")
  public ResponseEntity<JwtResponse> authenticateUser(@RequestBody LoginRequest loginRequest) {
    JwtResponse jwtResponse = authService.authenticateUser(loginRequest);
    return ResponseEntity.ok(jwtResponse);
  }

  @PostMapping("/signup")
  public ResponseEntity<MessageResponse> registerUser(@RequestBody RegisterRequest registerRequest) {
    try {
      authService.registerUser(registerRequest);
      return ResponseEntity.ok(new MessageResponse("User registered successfully!"));
    } catch (RuntimeException e) {
      return ResponseEntity.badRequest().body(new MessageResponse(e.getMessage()));
    }
  }
}

> package com.encapsulearn.quizApp.controller;

import com.encapsulearn.quizApp.dto.QuizAttemptDto;
import com.encapsulearn.quizApp.dto.QuizDto;
import com.encapsulearn.quizApp.dto.QuizSubmissionDto;
import com.encapsulearn.quizApp.entity.QuizAttempt;
import com.encapsulearn.quizApp.security.UserDetailsImpl;
import com.encapsulearn.quizApp.service.QuizService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api")
@CrossOrigin(origins = "${web.cors.allowed-origins}", maxAge = 3600)
public class QuizController {

  @Autowired
  private QuizService quizService;

  @GetMapping("/quizzes")
  public ResponseEntity<List<QuizDto>> getAllQuizzes(@RequestParam Optional<String> status) {
    return ResponseEntity.ok(quizService.getAllQuizzes(status));
  }

  @GetMapping("/quizzes/{id}")
  public ResponseEntity<QuizDto> getQuizById(@PathVariable Long id) {
    return ResponseEntity.ok(quizService.getQuizById(id));
  }

  @PostMapping("/quizzes/submit")
  public ResponseEntity<QuizAttempt> submitQuiz(@RequestBody QuizSubmissionDto submission,
      @AuthenticationPrincipal UserDetailsImpl userDetails) {
    QuizAttempt result = quizService.submitQuiz(submission, userDetails.getId());
    return ResponseEntity.ok(result);
  }

  @GetMapping("/history")
  public ResponseEntity<List<QuizAttemptDto>> getQuizHistory(@AuthenticationPrincipal UserDetailsImpl userDetails) {
    return ResponseEntity.ok(quizService.getQuizHistoryForUser(userDetails.getId()));
  }
}



7. security:
> package com.encapsulearn.quizApp.security;

import java.io.IOException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

public class JwtAuthenticationFilter extends OncePerRequestFilter {
  @Autowired
  private JwtUtils jwtUtils;
  @Autowired
  private UserDetailsServiceImpl userDetailsService;

  private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class);

  @SuppressWarnings("null")
  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
      throws ServletException, IOException {
    try {
      String jwt = parseJwt(request);
      if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
        String username = jwtUtils.getUserNameFromJwtToken(jwt);
        UserDetails userDetails = userDetailsService.loadUserByUsername(username);
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
            userDetails, null, userDetails.getAuthorities());
        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
        SecurityContextHolder.getContext().setAuthentication(authentication);
      }
    } catch (Exception e) {
      logger.error("Cannot set user authentication: {}", e.getMessage());
    }
    filterChain.doFilter(request, response);
  }

  private String parseJwt(HttpServletRequest request) {
    String headerAuth = request.getHeader("Authorization");
    if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
      return headerAuth.substring(7);
    }
    return null;
  }
}

> package com.encapsulearn.quizApp.security;

import java.util.Date;

import javax.crypto.SecretKey;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.security.core.Authentication;

import com.encapsulearn.quizApp.config.JwtProperties;

import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.UnsupportedJwtException;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;

@Component
public class JwtUtils {

  private static final Logger logger = LoggerFactory.getLogger(JwtUtils.class);
  private final JwtProperties jwtProperties;
  private final SecretKey key;

  public JwtUtils(JwtProperties jwtProperties) {
    this.jwtProperties = jwtProperties;
    this.key = Keys.hmacShaKeyFor(jwtProperties.getJwtSecret().getBytes());
  }

  public String generateJwtToken(Authentication authentication) {
    UserDetailsImpl userPrincipal = (UserDetailsImpl) authentication.getPrincipal();

    return Jwts.builder()
            .setSubject(userPrincipal.getUsername())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + jwtProperties.getJwtExpirationMs()))
            .signWith(key)
            .compact();
  }

  public String getUserNameFromJwtToken(String token) {
    return Jwts.parserBuilder().setSigningKey(key).build()
            .parseClaimsJws(token).getBody().getSubject();
  }

  public boolean validateJwtToken(String authToken) {
    try {
      Jwts.parserBuilder().setSigningKey(key).build().parse(authToken);
      return true;
    } catch (SignatureException e) {
      logger.error("Invalid JWT signature: {}", e.getMessage());
    } catch (MalformedJwtException e) {
      logger.error("Invalid JWT token: {}", e.getMessage());
    } catch (ExpiredJwtException e) {
      logger.error("JWT token is expired: {}", e.getMessage());
    } catch (UnsupportedJwtException e) {
      logger.error("JWT token is unsupported: {}", e.getMessage());
    } catch (IllegalArgumentException e) {
      logger.error("JWT claims string is empty: {}", e.getMessage());
    }
    return false;
  }
}

> package com.encapsulearn.quizApp.security;

import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import com.encapsulearn.quizApp.entity.User;
import com.fasterxml.jackson.annotation.JsonIgnore;

import lombok.Getter;

@Getter
public class UserDetailsImpl implements UserDetails {
  private Long id;
  private String username;
  private String email;
  @JsonIgnore
  private String password;
  private Collection<? extends GrantedAuthority> authorities;

  public UserDetailsImpl(Long id, String username, String email, String password,
      Collection<? extends GrantedAuthority> authorities) {
    this.id = id;
    this.username = username;
    this.email = email;
    this.password = password;
    this.authorities = authorities;
  }

  public static UserDetailsImpl build(User user) {
    List<GrantedAuthority> authorities = user.getRoles().stream()
        .map(role -> new SimpleGrantedAuthority(role.getName().name()))
        .collect(Collectors.toList());

    return new UserDetailsImpl(
        user.getId(),
        user.getUsername(),
        user.getEmail(),
        user.getPassword(),
        authorities);
  }

  @Override
  public boolean isAccountNonExpired() {
    return true;
  }

  @Override
  public boolean isAccountNonLocked() {
    return true;
  }

  @Override
  public boolean isCredentialsNonExpired() {
    return true;
  }

  @Override
  public boolean isEnabled() {
    return true;
  }
}

> package com.encapsulearn.quizApp.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import com.encapsulearn.quizApp.entity.User;
import com.encapsulearn.quizApp.repository.UserRepository;
import jakarta.transaction.Transactional;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
  @Autowired
  UserRepository userRepository;

  @Override
  @Transactional
  public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
    // We use email as the "username" for authentication
    User user = userRepository.findByEmail(email)
        .orElseThrow(() -> new UsernameNotFoundException("User Not Found with email: " + email));
    return UserDetailsImpl.build(user);
  }
}



8. config:
> package com.encapsulearn.quizApp.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

import com.encapsulearn.quizApp.entity.Role;
import com.encapsulearn.quizApp.enums.ERole;
import com.encapsulearn.quizApp.repository.RoleRepository;

@Component
public class DataSeeder implements CommandLineRunner {

  @Autowired
  private RoleRepository roleRepository;

  @Override
  public void run(String... args) throws Exception {
    // Check if roles are already in the database
    if (roleRepository.findByName(ERole.ROLE_USER).isEmpty()) {
      roleRepository.save(new Role(ERole.ROLE_USER));
    }
    if (roleRepository.findByName(ERole.ROLE_ADMIN).isEmpty()) {
      roleRepository.save(new Role(ERole.ROLE_ADMIN));
    }
  }
}

> package com.encapsulearn.quizApp.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import lombok.Data;

@Component
@ConfigurationProperties(prefix = "app")
@Data
public class JwtProperties {
  private String jwtSecret;
  private long jwtExpirationMs;
}

> package com.encapsulearn.quizApp.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;

import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

import com.encapsulearn.quizApp.security.JwtAuthenticationFilter;
import com.encapsulearn.quizApp.security.UserDetailsServiceImpl;

@Configuration
@EnableMethodSecurity
public class SecurityConfig {

  @Autowired
  private UserDetailsServiceImpl userDetailsService;

  @Bean
  public JwtAuthenticationFilter authenticationJwtTokenFilter() {
    return new JwtAuthenticationFilter();
  }

  @Bean
  public DaoAuthenticationProvider authenticationProvider() {
    DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
    authProvider.setUserDetailsService(userDetailsService);
    authProvider.setPasswordEncoder(passwordEncoder());
    return authProvider;
  }

  @Bean
  public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
    return authConfig.getAuthenticationManager();
  }

  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }

  @Bean
  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.csrf(csrf -> csrf.disable())
        .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests(auth -> auth
            .requestMatchers("/api/auth/**").permitAll()
            .requestMatchers("/api/admin/**").hasRole("ADMIN")
            .anyRequest().authenticated());

    http.authenticationProvider(authenticationProvider());
    http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);
    return http.build();
  }

  // Optional: Centralized CORS configuration
  @Bean
  public CorsFilter corsFilter() {
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    CorsConfiguration config = new CorsConfiguration();
    config.setAllowCredentials(true);
    config.addAllowedOrigin("http://localhost:4200");
    config.addAllowedHeader("*");
    config.addAllowedMethod("*");
    source.registerCorsConfiguration("/**", config);
    return new CorsFilter(source);
  }
}



9. application.properties: 
# Application name and server
spring.application.name=quizApp
server.port=8080

# Database configuration
spring.datasource.url=jdbc:mysql://localhost:3306/online_quiz_db
spring.datasource.username=root
spring.datasource.password=jee59
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# Hibernate / JPA configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# JWT Custom Properties (prefixed with "app" to match JwtProperties class)
app.jwtSecret=SuperSecretKeyForSpringBootQuizApplicationThatIsVeryLongAndSecure
app.jwt-expiration-ms=86400000

# CORS configuration
web.cors.allowed-origins=http://localhost:4200